# 이후 수업 내용

1. Docker 배포
2. GitHub 팀 관련 수업
3. AWS 배포

## 프로젝트 생성

1. React-TypeScript로 thirdpartyapp 생성
2. App.tsx를 초기화

# third-party-app

awesome react components
https://github.com/brillout/awesome-react-components?tab=readme-ov-file

1. 컴포넌트들은 README에서 볼 수 있듯이 npm을 통해서 설치가 가능합니다.
   - 설치 방법 : `npm install component_name@version`
   - date picker 설치 : `npm install react-date-picker@10.0.3`
   - 설치된 컴포넌트 삭제 : `npm uninstall component_name`
   - 업데이트가 누락된 컴포넌트들을 전부 다 검색하는 명령어 : `npm outdated`
   - 업데이트 누락된 컴포넌트들을 일괄 업데이트하는 명령어 : `npm update`
   - 모든 프로젝트 의존성 목록을 가져오는 명령어 : `npm list`

# AG Grid

- `npm install ag-grid-community@30.1.0 ag-grid-react@30.1.0`
  AG Grid는 리액트 앱을 위한 데이터 그리드 컴포넌트입니다.
- 스프레드 시트처럼 데이터를 표시하는데 이용하며, 상호작용도 가능합니다.
- 필터링 / 정렬 / 피벗과 같은 기능들을 포함했습니다.

```tsx
// 'githubaggrid/src/App.tsx
import { useState } from 'react';
import axios from 'axios';
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-material.css';
import './App.css';

type Repository = {
  id: number;
  full_name: string;
  html_url: string;
  owner: {
    login: string;
  };
};

function App() {
  const [keyword, setKeyword] = useState('');
  const [repodata, setRepodata] = useState<Repository[]>([]);

  const handleClick = () => {
    axios
      .get<{ items: Repository[] }>(`https://api.github.com/search/repositories?q=${keyword}`)
      .then((response) => setRepodata(response.data.items))
      .catch((error) => console.log(error));
  };

  return (
    <div className='App'>
      <input type='text' onChange={(e) => setKeyword(e.target.value)} value={keyword} />
      <button onClick={handleClick}>Search 👌</button>
      <div className='ag-theme-material' style={{ height: 500, width: 850 }}>
        <AgGridReact rowData={repodata} />
      </div>
    </div>
  );
}

export default App;
```

```tsx
import { AgGridReact } from 'ag-grid-react';
import 'ag-grid-community/styles/ag-grid.css';
import 'ag-grid-community/styles/ag-theme-material.css';
```

이상의 import 문들은 ag-grid 컴포넌트 자체와 스타일 시트를 가지고 왔습니다. 그 중에서도 마지막 css import는 google에서 권장하는 material style을 가지고 왔음을 뜻한다.

그러니까 사전 정으 ㅣ스타일을 가지고 옴으로써 css를 최소화 했습니다.
그런데 styles/ag-grid.css를 통해 최소한의 커스터마이징도 할 수 있는데, 이를 style={{height: 500, width: 850 }}로 처리

그리고 return문에 AgGridReact 컴포넌틑

그리고 ag-grid 컴포넌트 자체는 스타일을 정의하는 div element로 꼭 감싸줘야만 하기 때문이다.

```tsx
return (
  <div className='App'>
    <input type='text' onChange={(e) => setKeyword(e.target.value)} value={keyword} />
    <button onClick={handleClick}>Search 👌</button>
    <div className='ag-theme-material' style={{ height: 500, width: 850 }}>
      <AgGridReact rowData={repodata} />
    </div>
  </div>
);
```

이상과 같은 return 문이 작성되었습니다.

그 다음 과정을 ag-grid에 이용될 컬럼을 정의할 겁니다. 컬럼 정의 객체의 배열에 해당하는 columnDefs 라는 상태를 정의할것이다. 그리고 ag-grid는 여기에 이요할 수 있는 ColDef 타입을 제공합니다. (TypeScript로 쓰는 이유) 컬럼 객체에서는 필수 field프롭을 이용하여 데이터 접근자를 정의해야하는데, 여기서는 field 값이 컬럼이 표시해야하는 REST API 응답 데이터의 속성 이름이 될것이다.

```tsx

```

이상에서 컬럼의 정의 및 거기에 딸려있는 properties를 확인. sortable / filter 였고, 그 다음에 추가적인 컬럼을 정의했느데, 거기에 cellRenderer 라는 속성.

그리고 pagination paginationPageSize는 `<AgGridReact>` 컴포넌트 내부에 정의. return문과 colDefs 상태를 둘 다 잘 확인하시기 바랍니다.

cellRenderer 프롭을 이용하면 테이블 셀의 컨텐츠를 사용자 정의할 수 있다. 이상의 예시에서는 Ag Grid 내의 컬럼에서 버튼을 렌더링하는 예시.

cellRenderer 속성의 value는 callback 함수로 이루어져 있습니다. 그리고 매개변수로 params를 받았고, ICellRenderParams Type으로 작성했고, params.value의 값은 field속성에 정의된 full_name을 썻습니다. 그래서 버튼 누르면 full_name이 출력

근데 보니까 컬럼이름이 너무 대놓고 field와 동일하게 되어있습니다. 그러다 보니깐 column명을 확인해 보면 Id/ Full_name / Html_url / Full_name 으로 컬럼이 설정이 되었는것을 볼 수 있다.

# Material UI Component 이용

shoppinglist 프로젝트 생성
React - TypeScript
App.tsx 초기화
npm install @mui/material@5.14.8
npm install @emotion/react@11.11.1
npm install @emotion/styled@11.11.0

```tsx
import { Container } from '@mui/material';
import { AppBar, Toolbar, Typography } from '@mui/material';
import './App.css';

function App() {
  return (
    <Container>
      <AppBar position='static'>
        <Toolbar>
          <Typography variant='h6'>쇼핑 리스트 Shopping List</Typography>
        </Toolbar>
      </AppBar>
    </Container>
  );
}

export default App;
```

이상에서 주의깊게 봐야하는 부분은 각 컴포넌트가 무슨 역할을 하는지 입니다.
Container는 전체 브라우저 화면을 의미하고, AppBar는 상단을 의미합니다. 그리고 TooBar는 그 중에서도 nav와 비슷한 역할을 합니다.
Typography는 글씨 관련 영역을 나타냅니다.

이하 부터는 실제 shopping list의 기능과 관련된 부분을 작성할 예정입니다.
당연히 MUI를 도입한 부분이 될 것이기 때문에 일반적인 html + css + js + react의 형태로는 어떻게 작성 될 수 있을 지 감안하면서 작성할 예정이다.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from '@mui/material';
import { useState } from 'react';

function AddItem(props) {
  const [open, setOpen] = useState(false);

  const handleOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  return <>{/* asd */}</>;
}

export default AddItem;
```

App 컴포넌트 내에 AddItem 컴포넌트를 추가할 겁니다. 그런데 저희 todolist할 때는 input창에button 하나만 있었습니다. 그리고 github api 가지고 올 때도 그랬구요. 이번에는 Modal이라고 하는 개념을 추가 할 겁니다.

근데 이 Modal을 저희가 처음 배누는건 아니고 1만 시간의 법칙에서 했었습니다.

폼에 product와 amount라는 두 개의 입력 필드와 App 컴포넌트 내에 addItem 함수를 호출하는 버튼을 추가 할 겁니다. \_App 컴포넌트에 있는 addItem 함수를 호출할 수 있으려면 addItem 컴포넌트를 헨더링할 때 프롭으로 전달 해야합니다. 모달 Dialog 컴포넌트 외부에 사용자가 새 쇼핑항목을 입력할 수 있는 모달 폼을 여는 버튼을 추가해 둘겁니다. 해당 버튼은 컴포넌트가 처음 렌더링 될 때 보이는 유일한 요소에 해당.  
즉 최초에 open 상태가 false이기 때문에 모달 폼은 보이지 않고, 버튼만 보일것이라는 의미.

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from '@mui/material';
import { useState } from 'react';
import { Item } from './App';

function AddItem(props) {
  const [open, setOpen] = useState(false);
  const [item, setItem] = useState<Item>({
    product: '',
    amount: '',
  });

  const handleOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  return (
    <>
      <Button onClick={handleOpen}>Add Item</Button>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>New Item</DialogTitle>
        <DialogContent></DialogContent>
        <Button onClick={handleClose}>Cancel / 취소</Button>
        <Button onClick={addItem}>Add / 저장</Button>
      </Dialog>
    </>
  );
}

export default AddItem;
```

이상에서 일단 주의해서 봐야할 점은 App.tsx에 정의되어있는 type인 Item을 가지고 왔다는점. 이 것은 프로젝트 사이즈가 매우 작기 때문이고, 보통은 types.ts파일에 전체 타입들이 정의되어있고, 거기서 가지고 올 것ㅂ니다.

그리고 addItem 함수가 App.tsx에 정의되어있지만, AppItem컴포넌트에서 불러오고 잇습니다. 이 부분에 대해에서 의문을 가질 수 있다.

1. AddItem 컴포넌트 내에 addItem 함수를 정의하면 안되는가.
   - App.tsx의 addItem 함수를 확인한면 Item이 추가되고 기존의 items들을 그대로 스프레드 연산자로 받아온다는것을 확인할 수 있다.
   - 여기서 중요한 점은 AddItem 컴포넌트에서 하나의 item을 추가한 것을 상위로 보낼 방법이 없다는 접입니다.
   - React에서의 Data Flow는 상위 -> 하위로 이어지는 Top-Down 형식이기 때문입니다. 즉 addItem 컴포넌트에서 추가하는 함수를 별개로 만들어 봤자 App 컴포넌트로 보낼 수 없기 때문에 결과적으로 App 컴포넌트에서 addItem 함수를 만들고, 해당 함수를 호출하는 함수를 AddItem 컴포넌트에 정의행한다고 생각할 수 있겠습니다.
   - React에서의 기초적인 원리 부분에서 One way data flow에 대해 강조한 이유가 나오는 부분 중 하나입니다
   - 이게 너무 머리 아프면 recoil /

```tsx
import { Button, TextField, Dialog, DialogActions, DialogContent, DialogTitle } from '@mui/material';
import { useState } from 'react';
import { Item } from './App';

type AddItemProps = {
  addItem: (item: Item) => void;
};

function AddItem(props: AddItemProps) {
  const [open, setOpen] = useState(false);
  const [item, setItem] = useState<Item>({
    product: '',
    amount: '',
  });

  const handleOpen = () => {
    setOpen(true);
  };

  const handleClose = () => {
    setOpen(false);
  };

  // App.jsx의 addItem 함수를 호출하고, item 상태를 전달
  const addItem = () => {
    props.addItem(item);
    // TextField에 있는 내용을 다 지우고 Modal을 닫음
    setItem({ product: '', amount: '' });
    handleClose();
  };

  return (
    <>
      <Button onClick={handleOpen}>Add Item</Button>
      <Dialog open={open} onClose={handleClose}>
        <DialogTitle>New Item</DialogTitle>
        <DialogContent>
          <TextField
            value={item.product}
            margin='dense'
            onChange={(e) =>
              setItem({
                ...item,
                product: e.target.value,
              })
            }
            label='Product/제품'
            fullWidth
          />
          <TextField
            value={item.amount}
            margin='dense'
            onChange={(e) => setItem({ ...item, amount: e.target.value })}
            label='Amount/수량'
            fullWidth
          />
        </DialogContent>
        <Button onClick={handleClose}>Cancel / 취소</Button>
        <Button onClick={addItem}>Add / 저장</Button>
      </Dialog>
    </>
  );
}

export default AddItem;
```

이상의 코드에서 props로 전달하는 함수 부분에 주목하셔야 합니다. 이를 위해 AddItemProps type을 선언했습니다.

마찬가지로,
App.tsx로 확인하셔야 합니다. 함수를 전달하기 위한 방식이었습니다.

```tsx
import { Container } from '@mui/material';
import { AppBar, Toolbar, Typography } from '@mui/material';
import './App.css';
import { useState } from 'react';
import AddItem from './AddItem';

export type Item = {
  product: string;
  amount: string;
};

function App() {
  const [items, setItems] = useState<Item[]>([]);
  const addItem = (item: Item) => {
    setItems([item, ...items]);
  };

  return (
    <Container>
      <AppBar position='static'>
        <Toolbar>
          <Typography variant='h6'>쇼핑 리스트 Shopping List</Typography>
        </Toolbar>
      </AppBar>
      <AddItem addItem={addItem} />
    </Container>
  );
}

export default App;
```

그렇다면 현재까지 작성한 것을 기준으로 했을 때 App.tsx에 있는 items 상태가 업데이트 된다는 것은 확인할 수 있습니다.

근데 그 업데이트된 items를 보여주지 못하고 있네요.
그럼 업데이트된 items의 결과를 보여주는 return부분에서의 코드가 있어야 할 것 같습니다.

```tsx
import { Container } from '@mui/material';
import { AppBar, Toolbar, Typography } from '@mui/material';
import { List, ListItem, ListItemText } from '@mui/material';
import './App.css';
import { useState } from 'react';
import AddItem from './AddItem';

export type Item = {
  product: string;
  amount: string;
};

function App() {
  const [items, setItems] = useState<Item[]>([]);
  const addItem = (item: Item) => {
    setItems([item, ...items]);
  };

  return (
    <Container>
      <AppBar position='static'>
        <Toolbar>
          <Typography variant='h6'>쇼핑 리스트 Shopping List</Typography>
        </Toolbar>
      </AppBar>
      <AddItem addItem={addItem} />
      <List>
        {items.map((item, index) => (
          <ListItem key={index} divider>
            <ListItemText primary={item.product} secondary={item.amount} />
          </ListItem>
        ))}
      </List>
    </Container>
  );
}

export default App;
```

이상에서 확인해야 하는 점은 기본적으로 items 상태를 업데이트 하는 부분이 어느 부분에 작성되어야 하는가 입니다. 구조는 현재  
App  
↓  
AddItem  
컴포넌트 구조로 되어있습니다. 즉 , App 컴포넌트에 items 결과값을 표시할 것이냐, AddItem 컴포넌트에 표시할 것이냐 1/2 확률이라고 볼 수 있겠네요

심플하게 생각해 봤을 때, items 상태가 정의된 곳이 어디죠?  
App  
그래서 App에 결과값 표시했습니다.

List 컴포넌트를 App 컴포넌트 내에서 렌더링 했습니다. 지금 현재까지 MUI를 보시면 위계가 잡혀있다는 것을 알 수 있습니다.  
List -> ListItem -> ListItemText  
ul -> li 와 비슷하다.  
List 내에서 map() 함수를 활용하여 ListItem 컴포넌트를 생성(ul 내부에서 map 함수 써서 li만든것과 동일). 배열이기 때문에 key 프롭이 요구된다는 것도 동일 합니다.  
그리고 `<ListItem key={index} divider>` 에서 보시면 divider라는 속성이 있는데, 애는 각 항목 끝부분에서 구분선을 가지고 옵니다.
다음에 ListItemText에서 기본 텍스트로 product를 표시하고, 보조 텍스트로 amount를 표시했습니다. 각각 primary / secondary로 쓰였습니다. MUI에서 자주 쓰이는 속성입니다.

또한 button의 스타일이 있는데, variant="outlined/text/contained"로 쓸 수 있다.

이상의 MUI 라이브러리를 사용하면 리액트 앱에서 일관되게 디자인을 하는 것이 가능합니다. 그리고 좋은 점은 프로젝트를 찍어낼 때 CSS를 고려할 필요성이 덜하는 점이죠.

하지만 기본값이 정해져있는만큼 커스터마이징을 하기 위해서는 emotion 이나 tailwind를 고려할 필요도 있습니다.

React Router를 활용하여 라우팅 관리를 하는 법을 수업

# React Router

routerapp project 생성
npm install
npm install react-router-dom@6
App.tsx 초기화
Contact.tsx 생성 및 초기화

React Router란 URL을 기반으로 특정 컴포넌트를 렌더링할지 정의할 수 있는 방식

react-router-dom 라이브러리는 라우팅을 구현하는데 이용되는 컴포넌트들을 제공합니다.

1. BrowserRouter : 웹 기반 애플리케이션을 위한 라우터
2. Route : 주어진 위치가 일치하면 정의도니 컴포넌트를 렌더링
   이하는 Route 컴포넌트의 예시, element 속성은 사용자가 path 프롭에 정의된 contact 엔드 포인트로 이동할 때 렌더링 되는 컴포넌트를 정의. 경로는 현재 위치를 기준으로 상대 경로를 작성

   `<Route path="contact" element={<Contact />}>`  
    혹은 이하와 같이 path 속성 끝에* 와일드 카드릴 이용하는 것도 가능합니다.  
    `<Route path="/contact/*" element={<Contact />}>`  
   그러면 contact/mike 혹은 contact/1  등의 엔드퐁인트 들에 전부다 Contact 컴포넌트가 렌더링 됩니다.  
또한, Route 컴포넌트는 여러 Route 컴포넌트를 감싸는 것이 가능힙낟. 이를 위해서 Link 컴포넌트는 애플리케이션에 대한 탐색 기능을 제공하는데, 이하의 예시는 COntact 링크를 표시하면, 해당 링크를 클리했을 때`/contact`엔드 포인트로 이동합니다.  
`<Link to="/contact">Contact</Link>`

```tsx
import { BrowserRouter, Routes, Route, Link } from 'react-router-dom';
import Home from './Home';
import Contact from './Contact';
import './App.css';
import PageNotFound from './PageNotFound';
import ContactSeoul from './ContactSeoul';
import ContactBusan from './ContactBusan';

function App() {
  return (
    <>
      <BrowserRouter>
        <nav>
          <Link to='/'>Home</Link>
          {' | '}
          <Link to='/contact'>Contact</Link>
        </nav>
        <Routes>
          <Route path='/' element={<Home />} />
          <Route path='/contact' element={<Contact />}>
            <Route path='seoul' element={<ContactSeoul />} />
            <Route path='busan' element={<ContactBusan />} />
          </Route>
          <Route path='*' element={<PageNotFound />} />
        </Routes>
      </BrowserRouter>
    </>
  );
}

export default App;
```

`<Outlet />` : 중첩 라우트(Nested Routes)를 렌더링하기 위해 사용하는 일종의 자리표시자(placeholder)입니다.  
그러니까 Outlet 컴포넌트가 있는 장소에 해당 자식 컴포넌트를 불러내주세요, 라는 의미가 됩니다.  
그러면 이상으 ㅣ코드에서 보셨던 것처럼 App.tsx `<Route path='/contact' element={<Contact />}>`의 내부에 seoul과 busan엔드 포인트를 지정했고, 거기에 ContactSeoul과 ContactBusan을 명시하는것이 아니라 `<Outlet/>` 컴포넌트를 통해서 불러온다고 생각하시면 됩니다.

이상의 라이브러리를 이용할 경우 컴포넌트들이 하나의 URL(예를 들어 localhost:5173)만 가지는 것이 아니라 각각의 다른 URL을 가지도록 통제하여 필요한 부분만 렌더링할 수 있도록 합니다.

# 내용 요약

1. 3rd party 컴포넌트들을 학습.
   - react-date-picker는 그냥 설치 방법
   - AgGrid를 이용
     - 테이블을 대체하는 컴포넌트
       - filter, sort, column 정의와 관련된 부분을 학습
   - MUI 컴포넌트
   - 이상에서 중요한 것은 각각의 HTML 태그에 해당하는 컴포넌트들이 존재한다는 점입니다.
     - `<input>` 태그를 대체하는 것은 `<TextField>`인 등
     - 내부에 MUI 자체 property가 있기 때문에 학습 필요성 존재.
     - 귀찮게 하나하나 학습할거면 왜쓰냐 싶은데 이게 Css보다 훨씬 쉬워서 그렇다.
   - react-router-dom
     - SPA상에서 하나의 URL이 아니라 다수의 URL을 다루는 방식을 학습했습니다.
     - 조건부 렌더링이 if문이나 삼항연산자를 쓰는 것 뿐만 아니라, 내부의 URL을 기준으로 서로 다른 컴포넌트를 렌더링 할 수 있도록 하는 방식

외부 라이브러리를 다루는 현재 심점에서는 제 수업 자체보다는 공식 문서의 활용이 매우 중요. 프로젝트 때 어떤 라이브러리를 다룰지 모르기 때문에 그렇다.

# Full Stack 개발 - 스프링부트 RESTful API 웹 서비스를 위한 프론트엔트

## UI prototype

1. 데이터베이스의 자동차를 테이블에 나열하고, 페이징, sorting, filtering 기능을 구현 - Ag Grid를 써서
2. 데이터베이스에 새 차량을 추가할 수 있는 모달 폼을 여는 버튼을 구현. - MUI를 사용
3. 차량 테이블의 각 행에 자동차를 편집하거나 데이터베이스에서 삭제하는 버튼을 구현. Ag Grid에 있는데, 거기에 버튼을 클릭했을 때 특정 함수가 호출괴고, 그게 백엔드로 전달 -> DB로 들어가서 PUT 혹은 DELETE 메서드를 실행.
4. CSV 파일로 변형하여 내려받기가 가능한 링크 혹은 버튼을 구현해볼까 합니다.

## FrontEnd React 프로젝트 생성

carfront 프로젝트 생성
npm install
npm install @emotion/react@11.14.0
npm install @emotion/styled@11.14.0
npm install @mui/material@5.17.1
npm install @tanstack/react-query@4.36.1
npm install axios@1.9.0

App.tsx 초기화

```tsx
import { AppBar, Toolbar, Typography, Container, CssBaseline } from '@mui/material';

function App() {
  return (
    <>
      <Container maxWidth='xl'>
        <CssBaseline />
        <AppBar position='static'>
          <Toolbar>
            <Typography variant='h6'>Car Shop</Typography>
          </Toolbar>
        </AppBar>
      </Container>
    </>
  );
}

export default App;
```

Container : 맵 컨텐츠를 가로로 중앙에 배치하는 기본 레이아웃 컴포넌트

- maxWidth 앱의 최대 너비를 정의. 가장 큰 값을사용

AppBar : position 속성을 이용하여 앱 바가 어떻게 자리 잡을지 정의(static으로 잡았다).

- static 값은 사용자가 스크롤할 때 앱 바가 상단에 고정되지 않음
- fixed를 사용하면 상단에 고정

CssBaseline : 브라우저 간의 css 속성의 차이를 수정하는데 이용하는 컴포넌트로 여러 브라우저에서 리액트 애브이 모양이 동일하게 보이게씀 설정. 이 컴포넌트는 일반적으로 최상위 레벨에 포함되어 스타일이 전역적으로(css의 의미를 생각해야한다) 적용되게끔 합니디.

# CRUD 기능의 Frontend version

http://localhost:8080/api/cars

```json
{
  "_embedded": {
    "cars": [
      {
        "brand": "Kia",
        "model": "Seltos",
        "color": "Chacol",
        "registrationNumber": "370SU5690",
        "modelYear": 2020,
        "price": 30000000,
        "_links": {
          "self": {
            "href": "http://localhost:8080/api/cars/1"
          },
          "car": {
            "href": "http://localhost:8080/api/cars/1"
          },
          "owner": {
            "href": "http://localhost:8080/api/cars/1/owner"
          }
        }
      },
      {
        "brand": "Hyundai",
        "model": "Sonata",
        "color": "White",
        "registrationNumber": "123456",
        "modelYear": 2025,
        "price": 25000000,
        "_links": {
          "self": {
            "href": "http://localhost:8080/api/cars/2"
          },
          "car": {
            "href": "http://localhost:8080/api/cars/2"
          },
          "owner": {
            "href": "http://localhost:8080/api/cars/2/owner"
          }
        }
      },
      {
        "brand": "Honda",
        "model": "CR-V",
        "color": "Black-White",
        "registrationNumber": "987654",
        "modelYear": 2024,
        "price": 45000000,
        "_links": {
          "self": {
            "href": "http://localhost:8080/api/cars/3"
          },
          "car": {
            "href": "http://localhost:8080/api/cars/3"
          },
          "owner": {
            "href": "http://localhost:8080/api/cars/3/owner"
          }
        }
      }
    ]
  },
  "_links": {
    "self": {
      "href": "http://localhost:8080/api/cars?page=0&size=20"
    },
    "profile": {
      "href": "http://localhost:8080/api/profile/cars"
    },
    "search": {
      "href": "http://localhost:8080/api/cars/search"
    }
  },
  "page": {
    "size": 20,
    "totalElements": 3,
    "totalPages": 1,
    "number": 0
  }
}
```

cars 배열은 \_embedded.cars 노드에서 확인할 수 있습니다.

React query를 이용하여 네트워크를 구현하기 위해 npm install을 했다.

## BackEnd에서 데이터 가져오기

현재 타입스크립트를 사용하고 있기 때문에 Car 데이터 타입을 정의해야 합니다. 그래서 타입을 정의하는 새 파일들을 다 모아 놓고, 거기서 필요한 타입들만 import해서 빼올 수 있도록 하겠습니다.

src -> types.ts 파일을 만들겠습니다.  
그리고 자동차 객체는 어떻게 생겨야 하는지를 확인하기 위해 GET 요청 상에서 JSON 파일을 확인하겠습니다..

```json
{
  "brand": "Honda",
  "model": "CR-V",
  "color": "Black-White",
  "registrationNumber": "987654",
  "modelYear": 2024,
  "price": 45000000,
  "_links": {
    "self": {
      "href": "http://localhost:8080/api/cars/3"
    },
    "car": {
      "href": "http://localhost:8080/api/cars/3"
    },
    "owner": {
      "href": "http://localhost:8080/api/cars/3/owner"
    }
  }
}
```

```ts
export type CarResponse = {
  brand: string;
  model: string;
  color: string;
  registrationNumber: string;
  modelYear: number;
  price: number;
  _links: {
    self: {
      href: string;
    };
    car: {
      href: string;
    };
    owner: {
      href: string;
    };
  };
};
```

json에서의 자동차 element를 확인하여 프론트엔드 상에서 CarResponse type을 정의. 여러대의 차를 가지고 오고 싶으면 CarResponse[]가 되겠네요.

이후에 뭐할거냐면 localhost:8080/api/cars 엔드포인트에서 GET 요청을 해서 백엔드에서 자동차들을 가지고 올겁니다. 그러면 함수가 있어야 겠네요.

Carlist.tsx 작성

```

```
